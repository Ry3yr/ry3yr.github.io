<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MFM Builder â€” Interactive</title>
<style>
  :root{--accent:#7c3aed;--muted:#6b7280;--bg:#0b1220;--card:#071022;--glass:rgba(255,255,255,0.02)}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#041022,#071224);color:#e6eef8}
  .wrap{max-width:1100px;margin:20px auto;padding:18px}
  h1{margin:0 0 8px;font-size:18px;color:var(--accent)}
  p.lead{margin:0 0 16px;color:var(--muted);font-size:13px}
  .layout{display:grid;grid-template-columns:1fr 420px;gap:14px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
  label.block{display:block;margin-bottom:6px;font-size:13px;color:var(--muted)}
  textarea#input{text-rendering:optimizeLegibility;width:100%;min-height:120px;border-radius:8px;padding:10px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:#dbeafe;font-family:inherit;resize:vertical}
  .toolbar{display:flex;flex-direction:column;gap:8px}
  .group{display:flex;flex-wrap:wrap;gap:8px}
  button.btn{appearance:none;border:0;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);color:#dbeafe;cursor:pointer;font-weight:600}
  button.btn.alt{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);font-weight:600}
  .small{font-size:12px;color:var(--muted)}
  input[type="text"], input[type="number"], select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:#dbeafe}
  .row{display:flex;gap:8px;align-items:center}
  .preview-area{display:flex;flex-direction:column;gap:8px}
  textarea#mfm{height:120px;width:100%;border-radius:8px;padding:10px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:#dbeafe;font-family:ui-monospace,Menlo,monospace}
  .actions{display:flex;gap:8px;justify-content:space-between;align-items:center}
  .muted{color:var(--muted);font-size:12px}
  footer{margin-top:12px;color:var(--muted);font-size:12px}
  @media (max-width:980px){.layout{grid-template-columns:1fr;}}
  /* MFM preview specific styles */
  .mfm-preview blockquote{border-left:3px solid var(--accent);padding-left:12px;margin:8px 0;opacity:0.8}
  .mfm-preview pre{background:rgba(255,255,255,0.05);padding:10px;border-radius:6px;overflow-x:auto}
  .mfm-preview code{font-family:ui-monospace,Menlo,monospace;background:rgba(255,255,255,0.05);padding:2px 4px;border-radius:3px;font-size:0.9em}
  .mfm-preview .mfm-spin{display:inline-block;animation:mfm-spin 1.5s linear infinite}
  .mfm-preview .mfm-spin.x{display:inline-block;animation:mfm-spin-x 1.5s linear infinite}
  .mfm-preview .mfm-spin.y{display:inline-block;animation:mfm-spin-y 1.5s linear infinite}
  .mfm-preview .mfm-jump{display:inline-block;animation:mfm-jump 0.75s linear infinite}
  .mfm-preview .mfm-bounce{display:inline-block;animation:mfm-bounce 0.75s linear infinite}
  .mfm-preview .mfm-shake{display:inline-block;animation:mfm-shake 0.5s ease infinite}
  .mfm-preview .mfm-twitch{display:inline-block;animation:mfm-twitch 0.5s ease infinite}
  .mfm-preview .mfm-rainbow{animation:mfm-rainbow 3s linear infinite}
  .mfm-preview .mfm-sparkle{position:relative;display:inline-block}
  .mfm-preview .mfm-flip{transform:scale(-1,-1);display:inline-block}
  .mfm-preview .mfm-flip.h{transform:scale(-1,1);display:inline-block}
  .mfm-preview .mfm-flip.v{transform:scale(1,-1);display:inline-block}
  .mfm-preview .mfm-x2{transform:scale(2);display:inline-block;transform-origin:left center}
  .mfm-preview .mfm-x3{transform:scale(3);display:inline-block;transform-origin:left center}
  .mfm-preview .mfm-x4{transform:scale(4);display:inline-block;transform-origin:left center}
  @keyframes mfm-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
  @keyframes mfm-spin-x{0%{transform:rotateX(0deg)}100%{transform:rotateX(360deg)}}
  @keyframes mfm-spin-y{0%{transform:rotateY(0deg)}100%{transform:rotateY(360deg)}}
  @keyframes mfm-jump{0%,100%{transform:translateY(0)}50%{transform:translateY(-0.5em)}}
  @keyframes mfm-bounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-0.25em)}}
  @keyframes mfm-shake{0%{transform:translateX(0)}25%{transform:translateX(-5px)}50%{transform:translateX(0)}75%{transform:translateX(5px)}100%{transform:translateX(0)}}
  @keyframes mfm-twitch{0%{transform:translateX(0) rotate(0deg)}5%{transform:translateX(0) rotate(0deg)}6%{transform:translateX(0) rotate(-3deg)}10%{transform:translateX(0) rotate(3deg)}15%{transform:translateX(0) rotate(0deg)}}
  @keyframes mfm-rainbow{0%{color:#ff0000}14%{color:#ff7f00}28%{color:#ffff00}42%{color:#00ff00}56%{color:#0000ff}70%{color:#4b0082}84%{color:#9400d3}100%{color:#ff0000}}
</style>
</head>
<body>
<div class="wrap">
  <h1>MFM Builder</h1>
  <p class="lead">Type text, apply modifiers from groups, preview MFM source, then copy to clipboard.</p>
  <div class="layout">
    <div class="card">
      <label class="block">Input text (you can select part of text and apply modifiers to selection)</label>
      <textarea id="input" placeholder="Type here â€” e.g. Misskeyã§Fediverse ðŸ®"></textarea>

      <div style="height:10px"></div>

      <div class="toolbar">
        <div>
          <div class="small" style="margin-bottom:6px">Formatting</div>
          <div class="group" id="format-group">
            <button class="btn" data-action="wrap" data-value="**{t}**">Bold</button>
            <button class="btn" data-action="wrap" data-value="~~{t}~~">Strikethrough</button>
            <button class="btn" data-action="wrap" data-value="`{t}`">Inline code</button>
            <button class="btn" data-action="wrap" data-value="> {t}">Quote</button>
            <button class="btn" data-action="wrap" data-value="<small>{t}</small>">Small</button>
            <button class="btn" data-action="wrap" data-value="<center>{t}</center>">Center</button>
            <button class="btn" data-action="wrap" data-value=":$:{t}:$:">CustomEmoji (name)</button>
          </div>
        </div>

        <div>
          <div class="small" style="margin-bottom:6px">Transforms / Layout</div>
          <div class="group" id="transform-group">
            <button class="btn" data-action="wrap" data-value="$[flip {t}]">Flip</button>
            <button class="btn" data-action="wrap" data-value="$[flip.h {t}]">Flip H</button>
            <button class="btn" data-action="wrap" data-value="$[flip.v {t}]">Flip V</button>
            <button class="btn" data-action="wrap" data-value="$[rotate.deg={deg} {t}]">Rotate</button>
            <button class="btn" data-action="wrap" data-value="$[position.x={px} {t}]">Shift X</button>
            <button class="btn" data-action="wrap" data-value="$[position.y={py} {t}]">Shift Y</button>
            <button class="btn" data-action="wrap" data-value="$[scale.x={sx},y={sy} {t}]">Scale</button>
          </div>
          <div class="row" style="margin-top:6px;gap:10px">
            <input type="number" id="deg" placeholder="deg" style="width:86px"/>
            <input type="text" id="px" placeholder="x offset (e.g. 1.5)" style="width:120px"/>
            <input type="text" id="py" placeholder="y offset" style="width:120px"/>
            <input type="text" id="sx" placeholder="scale x" style="width:86px"/>
            <input type="text" id="sy" placeholder="scale y" style="width:86px"/>
          </div>
        </div>

        <div>
          <div class="small" style="margin-bottom:6px">Animations / Effects</div>
          <div class="group" id="anim-group">
            <button class="btn" data-action="wrap" data-value="$[jelly {t}]">Jelly</button>
            <button class="btn" data-action="wrap" data-value="$[tada {t}]">Tada</button>
            <button class="btn" data-action="wrap" data-value="$[jump {t}]">Jump</button>
            <button class="btn" data-action="wrap" data-value="$[bounce {t}]">Bounce</button>
            <button class="btn" data-action="wrap" data-value="$[spin {t}]">Spin</button>
            <button class="btn" data-action="wrap" data-value="$[spin.x {t}]">Spin X</button>
            <button class="btn" data-action="wrap" data-value="$[spin.y {t}]">Spin Y</button>
            <button class="btn" data-action="wrap" data-value="$[shake {t}]">Shake</button>
            <button class="btn" data-action="wrap" data-value="$[twitch {t}]">Twitch</button>
            <button class="btn" data-action="wrap" data-value="$[sparkle {t}]">Sparkle</button>
          </div>
          <div style="margin-top:6px" class="group">
            <button class="btn" data-action="wrap" data-value="$[rainbow {t}]">Rainbow</button>
            <button class="btn" data-action="wrap" data-value="$[x2 {t}]">$[x2]</button>
            <button class="btn" data-action="wrap" data-value="$[x3 {t}]">$[x3]</button>
            <button class="btn" data-action="wrap" data-value="$[x4 {t}]">$[x4]</button>
          </div>
        </div>

        <div>
          <div class="small" style="margin-bottom:6px">Decorations / Border / Color</div>
          <div class="group">
            <button class="btn" data-action="wrap" data-value="$[border.style=solid,width=4 {t}]">Border solid</button>
            <button class="btn" data-action="wrap" data-value="$[border.color={bcol} {t}]">Border color</button>
            <button class="btn" data-action="wrap" data-value="$[fg.color={fcol} {t}]">FG color</button>
            <button class="btn" data-action="wrap" data-value="$[bg.color={bkg} {t}]">BG color</button>
            <button class="btn" data-action="wrap" data-value="$[blur {t}]">Blur</button>
          </div>
          <div class="row" style="margin-top:6px">
            <input type="text" id="bcol" placeholder="border color (hex like f00)" style="width:120px"/>
            <input type="text" id="fcol" placeholder="fg color (hex)" style="width:120px"/>
            <input type="text" id="bkg" placeholder="bg color (hex)" style="width:120px"/>
          </div>
        </div>

        <div>
          <div class="small" style="margin-bottom:6px">Advanced / Others</div>
          <div class="group">
            <button class="btn" data-action="wrap" data-value="$[ruby {t} {ruby}]">$[ruby]</button>
            <button class="btn" data-action="wrap" data-value="` ```{lang}\n{t}\n``` `">Code block</button>
            <button class="btn" data-action="wrap" data-value="[{text}]({url})">Link</button>
            <button class="btn" data-action="wrap" data-value="?[{text}]({url})">Hidden preview link</button>
          </div>
          <div class="row" style="margin-top:6px">
            <input type="text" id="ruby" placeholder="ruby text" style="width:180px"/>
            <input type="text" id="lang" placeholder="lang id (e.g. ais)" style="width:120px"/>
            <input type="text" id="url" placeholder="https://..." style="width:180px"/>
          </div>
        </div>

      </div>
    </div>

    <div class="card preview-area">
      <div>
        <label class="block">Generated MFM source</label>
        <textarea id="mfm" readonly placeholder="MFM result will appear here"></textarea>
      </div>

      <div class="actions">
        <div style="display:flex;gap:8px">
          <button id="copy" class="btn">Copy MFM</button>
          <button id="reset" class="btn alt">Reset</button>
          <button id="wrap-selection" class="btn alt">Wrap selection with custom</button>
        </div>
        <div style="text-align:right">
          <div class="muted" id="status">Ready</div>
        </div>
      </div>

      <div style="margin-top:10px">
        <label class="block">Preview (best-effort plain preview â€” actual Misskey client renders MFM differently)</label>
        <div id="visualPreview" class="mfm-preview" style="min-height:80px;padding:10px;border-radius:8px;background:var(--glass);border:1px solid rgba(255,255,255,0.03);color:#dbeafe;font-size:14px"></div>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
        <div class="small">Auto-update MFM:</div>
        <label class="small"><input type="checkbox" id="auto" checked/> live</label>
      </div>
    </div>
  </div>

  <footer>Single-file. Works offline. Uses navigator.clipboard with fallback.</footer>
</div>

<script>
/* Full client-side MFM builder logic.
   - Buttons with data-action="wrap" and data-value use templates where {t} is text,
     and other placeholders (deg, px, py, sx, sy, bcol, fcol, bkg, ruby, lang, url, text) are replaced
     with inputs from the toolbar.
   - If selection exists in #input, wrap selection; otherwise wrap entire input.
   - Live updates MFM output and a simple visual preview (plain text with some replacements).
*/

/* helpers */
function el(q, root=document) { return root.querySelector(q); }
function els(q, root=document) { return Array.from(root.querySelectorAll(q)); }
function setStatus(txt, ok=true) { const s = el('#status'); s.textContent = txt; s.style.color = ok ? '' : '#ff9b9b'; }

/* get values */
function getVal(id){ const e = el('#'+id); return e ? e.value : ''; }

/* create wrapper with template */
function buildWrapper(template, text) {
  if (!template) return text;
  // gather replacements
  const repl = {
    t: text,
    deg: getVal('deg'),
    px: getVal('px'),
    py: getVal('py'),
    sx: getVal('sx') || '2',
    sy: getVal('sy') || getVal('sx') || '2',
    bcol: getVal('bcol'),
    fcol: getVal('fcol'),
    bkg: getVal('bkg'),
    ruby: getVal('ruby'),
    lang: getVal('lang'),
    url: getVal('url'),
    text: text
  };
  // For code block template that used backticks wrappers we may have weird spacing; allow {lang} insertion.
  let out = template;
  Object.keys(repl).forEach(k => {
    const v = repl[k] === undefined ? '' : repl[k];
    // escape braces in replacement value for safe replacement
    out = out.split('{' + k + '}').join(v);
  });
  return out;
}

/* apply wrapper to selection or whole input */
function applyWrapperToInput(template) {
  const ta = el('#input');
  ta.focus();
  const start = ta.selectionStart;
  const end = ta.selectionEnd;
  const before = ta.value.slice(0, start);
  const sel = (start !== end) ? ta.value.slice(start, end) : ta.value.slice(0); // if no selection, will wrap whole text (from 0)
  // If no selection and there is text, wrap entire text; if empty, insert placeholder
  const textToWrap = sel.length ? sel : 'your text';
  const wrapped = buildWrapper(template, textToWrap);
  if (start !== end) {
    ta.value = before + wrapped + ta.value.slice(end);
    // reselect newly wrapped content
    ta.setSelectionRange(before.length, before.length + wrapped.length);
  } else {
    // no selection: replace entire or insert at cursor
    if (ta.value.length) {
      // wrap entire value
      ta.value = wrapped;
      ta.setSelectionRange(0, wrapped.length);
    } else {
      // insert placeholder wrapped at cursor
      ta.value = wrapped;
      ta.setSelectionRange(0, wrapped.length);
    }
  }
  updateAll();
}

/* take a template that may be a link template like "[{text}]({url})" - support special flow:
   if template contains "[{text}]" then the tool expects 'text' and 'url' inputs. */
function handleWrapButton(btn) {
  const template = btn.getAttribute('data-value');
  applyWrapperToInput(template);
}

/* Custom MFM parser for preview */
function parseMFM(text) {
  if (!text) return '';
  
  // First parse code blocks to prevent interpreting their contents as MFM
  const codeBlockRegex = /```([a-z]*)\n([\s\S]*?)\n```/g;
  text = text.replace(codeBlockRegex, (match, lang, code) => {
    return `<pre><code class="language-${lang}">${escapeHTML(code)}</code></pre>`;
  });

  // Then parse inline code
  text = text.replace(/`([^`]+)`/g, (match, code) => {
    return `<code>${escapeHTML(code)}</code>`;
  });

  // Parse MFM functions ($[...])
  const mfmFuncRegex = /\$\[([a-z.]+)(?:=([^\]]+))? (.*?)\]/g;
  text = text.replace(mfmFuncRegex, (match, func, params, content) => {
    content = parseMFM(content); // Recursively parse nested content
    switch(func) {
      case 'flip':
        return `<span class="mfm-flip">${content}</span>`;
      case 'flip.h':
        return `<span class="mfm-flip h">${content}</span>`;
      case 'flip.v':
        return `<span class="mfm-flip v">${content}</span>`;
      case 'spin':
        return `<span class="mfm-spin">${content}</span>`;
      case 'spin.x':
        return `<span class="mfm-spin x">${content}</span>`;
      case 'spin.y':
        return `<span class="mfm-spin y">${content}</span>`;
      case 'jump':
        return `<span class="mfm-jump">${content}</span>`;
      case 'bounce':
        return `<span class="mfm-bounce">${content}</span>`;
      case 'shake':
        return `<span class="mfm-shake">${content}</span>`;
      case 'twitch':
        return `<span class="mfm-twitch">${content}</span>`;
      case 'rainbow':
        return `<span class="mfm-rainbow">${content}</span>`;
      case 'x2':
        return `<span class="mfm-x2">${content}</span>`;
      case 'x3':
        return `<span class="mfm-x3">${content}</span>`;
      case 'x4':
        return `<span class="mfm-x4">${content}</span>`;
      case 'position.x':
      case 'position.y':
        // Position is tricky to preview - just show content
        return content;
      case 'rotate.deg':
        const deg = params ? params.split('=')[1] : '0';
        return `<span style="display:inline-block;transform:rotate(${deg}deg)">${content}</span>`;
      case 'scale.x':
      case 'scale.y':
        // Scale params might be x=2,y=3 or just x=2
        let scaleX = '1', scaleY = '1';
        if (params) {
          const parts = params.split(',');
          parts.forEach(part => {
            const [key, value] = part.split('=');
            if (key === 'x') scaleX = value;
            if (key === 'y') scaleY = value;
          });
        }
        return `<span style="display:inline-block;transform:scale(${scaleX},${scaleY})">${content}</span>`;
      case 'fg.color':
        const fgColor = params || 'inherit';
        return `<span style="color:#${fgColor}">${content}</span>`;
      case 'bg.color':
        const bgColor = params || 'transparent';
        return `<span style="background-color:#${bgColor};padding:0 2px;border-radius:3px">${content}</span>`;
      case 'border.color':
        const borderColor = params || 'currentColor';
        return `<span style="border:1px solid #${borderColor};padding:0 2px;border-radius:3px">${content}</span>`;
      case 'border.style':
        // Parse border style params (style=solid,width=4)
        let borderStyle = 'solid', borderWidth = '1px';
        if (params) {
          const parts = params.split(',');
          parts.forEach(part => {
            const [key, value] = part.split('=');
            if (key === 'style') borderStyle = value;
            if (key === 'width') borderWidth = value + 'px';
          });
        }
        return `<span style="border:${borderWidth} ${borderStyle} currentColor;padding:0 2px;border-radius:3px">${content}</span>`;
      case 'ruby':
        // Ruby text is in the content part (content is "base ruby")
        const parts = content.split(/\s+/);
        if (parts.length >= 2) {
          const base = parts.slice(0, -1).join(' ');
          const ruby = parts[parts.length - 1];
          return `<ruby>${base}<rt>${ruby}</rt></ruby>`;
        }
        return content;
      default:
        return content;
    }
  });

  // Parse markdown-like syntax
  text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  text = text.replace(/~~(.*?)~~/g, '<del>$1</del>');
  text = text.replace(/> (.*)/g, '<blockquote>$1</blockquote>');
  text = text.replace(/<small>(.*?)<\/small>/g, '<small>$1</small>');
  text = text.replace(/<center>(.*?)<\/center>/g, '<div style="text-align:center">$1</div>');

  // Parse links
  text = text.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
  text = text.replace(/\?\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" style="text-decoration:none;color:inherit">$1</a>');

  // Parse custom emoji
  text = text.replace(/:(\w+):/g, '<span style="display:inline-block;background:rgba(255,255,255,0.1);border-radius:4px;padding:0 2px">:$1:</span>');

  return text;
}

function escapeHTML(str) {
  return str.replace(/[&<>'"]/g, 
    tag => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      "'": '&#39;',
      '"': '&quot;'
    }[tag]));
}

/* update MFM textarea from input */
function updateAll() {
  const input = el('#input').value;
  // For now the "generated MFM source" is the raw input (modifiers are applied by buttons)
  el('#mfm').value = input;
  // Use our custom MFM parser for the preview
  el('#visualPreview').innerHTML = parseMFM(input);
}

/* copy to clipboard with fallback */
async function copyText(text) {
  if (!text) return false;
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try { await navigator.clipboard.writeText(text); return true; } catch(e) {}
  }
  try {
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand('copy');
    document.body.removeChild(ta);
    return ok;
  } catch(e) { return false; }
}

/* wire buttons */
document.addEventListener('click', (ev) => {
  const btn = ev.target.closest('button[data-action="wrap"]');
  if (btn) {
    handleWrapButton(btn);
    setStatus('Wrapped');
    return;
  }
});

els('button.btn').forEach(b => {
  // non-wrap buttons already handled using data-action attribute in event delegation
});

/* copy button */
el('#copy').addEventListener('click', async () => {
  const txt = el('#mfm').value;
  const ok = await copyText(txt);
  setStatus(ok ? 'Copied to clipboard' : 'Copy failed', ok);
});

/* reset */
el('#reset').addEventListener('click', () => {
  el('#input').value = '';
  el('#mfm').value = '';
  el('#visualPreview').innerHTML = '';
  setStatus('Reset');
});

/* wrap-selection: prompt for a custom template and wrap selection or entire text */
el('#wrap-selection').addEventListener('click', () => {
  const tpl = prompt('Enter wrapper template with {t} as placeholder (e.g. $[spin {t}])','$[spin {t}]');
  if (!tpl) return;
  applyWrapperToInput(tpl);
  setStatus('Applied custom wrapper');
});

/* live updates */
el('#input').addEventListener('input', () => {
  if (el('#auto').checked) updateAll();
});
els('input').forEach(i=>i.addEventListener('change', () => { if (el('#auto').checked) updateAll(); }));

/* initialize */
updateAll();
setStatus('Ready');

/* Accessibility: keyboard shortcuts */
document.addEventListener('keydown', (ev) => {
  if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'b') {
    // ctrl/cmd+B toggle bold on selection
    ev.preventDefault();
    applyWrapperToInput('**{t}**');
    setStatus('Bold applied');
  }
});
</script>
</body>
</html>